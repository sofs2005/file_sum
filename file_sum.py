# encoding:utf-8
import json
import os
import csv
import re
import requests
import plugins
from bridge.context import ContextType
from bridge.reply import Reply, ReplyType
from common.log import logger
from common.expired_dict import ExpiredDict
from plugins import *
from docx import Document
from bs4 import BeautifulSoup
from pptx import Presentation
from openpyxl import load_workbook
import fitz  # PyMuPDF

# Êñá‰ª∂Êâ©Â±ïÂêçÂà∞Á±ªÂûãÁöÑÊò†Â∞Ñ
EXTENSION_TO_TYPE = {
    'pdf': 'pdf',
    'docx': 'docx',
    'doc': 'docx',
    'md': 'md',
    'markdown': 'md',
    'txt': 'txt',
    'xlsx': 'excel',
    'xls': 'excel',
    'csv': 'csv',
    'html': 'html',
    'htm': 'html',
    'pptx': 'ppt',
    'ppt': 'ppt'
}

@plugins.register(
    name="FileSum",
    desire_priority=20,
    hidden=False,
    desc="A plugin for summarizing files",
    version="1.0.0",
    author="sofs2005",
)
class FileSum(Plugin):
    def __init__(self):
        super().__init__()
        try:
            # Âä†ËΩΩÈÖçÁΩÆ
            self.config = super().load_config()
            if not self.config:
                self.config = self._load_config_template()
            
            # ÂàùÂßãÂåñÈÖçÁΩÆ
            self.open_ai_api_key = self.config.get("open_ai_api_key", "")
            self.open_ai_api_base = self.config.get("open_ai_api_base", "https://api.openai.com/v1")
            self.model = self.config.get("model", "gpt-3.5-turbo")
            self.enabled = self.config.get("enabled", True)
            self.max_file_size = self.config.get("max_file_size", 15000)
            self.max_token_size = self.config.get("max_token_size", 4000)
            self.group = self.config.get("group", True)
            self.qa_prefix = self.config.get("qa_prefix", "ÈóÆ")
            self.prompt = self.config.get("prompt", "ËØ∑ÊÄªÁªìËøô‰∏™Êñá‰ª∂ÁöÑ‰∏ªË¶ÅÂÜÖÂÆπ")
            
            # ÂàùÂßãÂåñÁºìÂ≠ò
            self.file_cache = ExpiredDict(self.config.get("file_cache_time", 60))
            self.content_cache = ExpiredDict(self.config.get("content_cache_time", 300))
            self.params_cache = {}
            
            # Ê≥®ÂÜå‰∫ã‰ª∂Â§ÑÁêÜÂô®
            self.handlers[Event.ON_HANDLE_CONTEXT] = self.on_handle_context
            
            logger.info("[FileSum] Plugin initialized")
        except Exception as e:
            logger.error(f"[FileSum] Init failed: {e}")
            raise e

    def get_help_text(self, **kwargs):
        help_text = "üìÑ Êñá‰ª∂ÊÄªÁªìÊèí‰ª∂‰ΩøÁî®ËØ¥ÊòéÔºö\n"
        help_text += "1. ÂèëÈÄÅÊñá‰ª∂ÂêéÔºåÂçïËÅä‰ºöËá™Âä®ÊÄªÁªì\n"
        help_text += "2. Áæ§ËÅäÈúÄË¶ÅÂèëÈÄÅ„ÄåÊÄªÁªì„ÄçËß¶ÂèëÊÄªÁªì\n"
        help_text += f"3. ÊÄªÁªìÂÆåÊàêÂêé5ÂàÜÈíüÂÜÖÂèØÂèëÈÄÅ„Äå{self.qa_prefix}xxx„ÄçËøΩÈóÆÊñá‰ª∂ÂÜÖÂÆπ\n"
        help_text += "\nÊîØÊåÅÊ†ºÂºèÔºöPDF„ÄÅWord„ÄÅExcel„ÄÅPPT„ÄÅTXT„ÄÅMarkdown„ÄÅHTML„ÄÅCSV"
        return help_text

    def _load_config_template(self):
        try:
            plugin_config_path = os.path.join(self.path, "config.json.template")
            if os.path.exists(plugin_config_path):
                with open(plugin_config_path, "r", encoding="utf-8") as f:
                    return json.load(f)
        except Exception as e:
            logger.error(f"[FileSum] Load config template failed: {e}")
        return {}

    def on_handle_context(self, e_context: EventContext):
        context = e_context["context"]
        msg: ChatMessage = e_context["context"]["msg"]
        
        # ‰øÆÊîπÁºìÂ≠òÈîÆÁöÑÁîüÊàêÊñπÂºèÔºåÂπ∂Ê∑ªÂä†Êõ¥Â§öÊó•Âøó
        chat_id = context.get("session_id", "default")
        logger.info(f"[FileSum] ÂéüÂßã chat_id: {chat_id}")
        
        user_id = msg.from_user_id
        logger.info(f"[FileSum] ÂéüÂßã user_id: {user_id}")
        
        # Ê∏ÖÁêÜID‰∏≠ÁöÑÁâπÊÆäÂ≠óÁ¨¶
        chat_id = chat_id.replace('@', '').split('_')[0]
        user_id = user_id.replace('@', '').split('_')[0]
        
        logger.info(f"[FileSum] Â§ÑÁêÜÂêé chat_id: {chat_id}")
        logger.info(f"[FileSum] Â§ÑÁêÜÂêé user_id: {user_id}")
        
        isgroup = e_context["context"].get("isgroup", False)
        
        # ÁîüÊàêÁºìÂ≠òkey
        cache_key = f"filesum_{chat_id}_{user_id}"
        logger.info(f"[FileSum] ÁîüÊàêÁºìÂ≠òÈîÆ: {cache_key}")

        if isgroup and not self.group:
            logger.info("[FileSum] Áæ§ËÅäÊ∂àÊÅØÔºåÊñá‰ª∂Â§ÑÁêÜÂäüËÉΩÂ∑≤Á¶ÅÁî®")
            return

        # Â§ÑÁêÜÊñá‰ª∂Ê∂àÊÅØ
        if context.type == ContextType.FILE and self.enabled:
            logger.info(f"[FileSum] Êî∂Âà∞Êñá‰ª∂ÔºåÂ≠òÂÖ•ÁºìÂ≠òÔºåkey={cache_key}")
            context.get("msg").prepare()
            file_path = context.content
            
            self.file_cache[cache_key] = {
                'file_path': file_path,
                'processed': False
            }
            logger.info(f"[FileSum] Êñá‰ª∂Ë∑ØÂæÑÂ∑≤ÁºìÂ≠ò: {file_path}")

            # Â¶ÇÊûúÊòØÂçïËÅäÔºåÁõ¥Êé•Ëß¶ÂèëÊÄªÁªì
            if not isgroup:
                logger.info("[FileSum] ÂçïËÅäÊ∂àÊÅØÔºåËá™Âä®Ëß¶ÂèëÊÄªÁªì")
                return self._process_file_summary(cache_key, e_context)
            return

        # Â§ÑÁêÜÊñáÊú¨Ê∂àÊÅØ
        if context.type == ContextType.TEXT and self.enabled:
            text = context.content
            
            # Ê£ÄÊü•ÊòØÂê¶ÊòØËøΩÈóÆ
            if text.startswith(self.qa_prefix):
                logger.info(f"[FileSum] Ê£ÄÊµãÂà∞ËøΩÈóÆËØ∑Ê±Ç: {text}")
                
                # Ê£ÄÊü•ÁºìÂ≠òÁä∂ÊÄÅ
                if cache_key in self.content_cache:
                    logger.info(f"[FileSum] ÊâæÂà∞ÂÜÖÂÆπÁºìÂ≠òÔºåkey={cache_key}")
                    cache_data = self.content_cache[cache_key]
                    
                    if cache_data and 'file_content' in cache_data:
                        logger.info("[FileSum] ÊâæÂà∞ÊúâÊïàÁöÑÊñá‰ª∂ÂÜÖÂÆπÁºìÂ≠ò")
                        question = text[len(self.qa_prefix):].strip()
                        # Áõ¥Êé•Â§ÑÁêÜËøΩÈóÆÂπ∂ËøîÂõûÔºå‰∏çÂÜçÁªßÁª≠
                        self.handle_question(cache_data['file_content'], question, e_context)
                        return
                    
                logger.info("[FileSum] Ê≤°ÊúâÊâæÂà∞ÊúâÊïàÁöÑÊñá‰ª∂ÂÜÖÂÆπÁºìÂ≠ò")
                return

            # Áæ§ËÅä‰∏≠ÁöÑÊÄªÁªìËß¶ÂèëÂëΩ‰ª§
            elif isgroup and text.strip() == "ÊÄªÁªì":
                logger.info("[FileSum] Áæ§ËÅä‰∏≠Êî∂Âà∞ÊÄªÁªìÂëΩ‰ª§")
                if cache_key in self.file_cache:
                    logger.info(f"[FileSum] ÊâæÂà∞Êñá‰ª∂ÁºìÂ≠òÔºåÂºÄÂßãÂ§ÑÁêÜÊÄªÁªì")
                    return self._process_file_summary(cache_key, e_context)
                else:
                    logger.info("[FileSum] Êú™ÊâæÂà∞ÂæÖÂ§ÑÁêÜÁöÑÊñá‰ª∂ÔºåËÆ©‰∫ã‰ª∂ÁªßÁª≠‰º†ÈÄí")
                    return False  # ËøîÂõû False ËÆ©‰∫ã‰ª∂ÁªßÁª≠‰º†ÈÄíÁªôÂÖ∂‰ªñÊèí‰ª∂ÔºàÂ¶Ç JinaSumÔºâ

        return False

    def _process_file_summary(self, cache_key: str, e_context: EventContext):
        """Â§ÑÁêÜÊñá‰ª∂ÊÄªÁªìÁöÑÊ†∏ÂøÉÈÄªËæë"""
        cache_data = self.file_cache.get(cache_key)
        if not cache_data:
            logger.info("[filesum] Êú™ÊâæÂà∞ÁºìÂ≠òÁöÑÊñá‰ª∂")
            return
        
        if cache_data.get('processed', False):
            logger.info("[filesum] ËØ•Êñá‰ª∂Â∑≤ÁªèÂ§ÑÁêÜËøá")
            return

        file_path = cache_data.get('file_path')
        if not file_path or not os.path.exists(file_path):
            logger.info("[filesum] ÁºìÂ≠òÁöÑÊñá‰ª∂‰∏çÂ≠òÂú®")
            reply = Reply(ReplyType.ERROR, "Êñá‰ª∂Â∑≤ËøáÊúüÔºåËØ∑ÈáçÊñ∞ÂèëÈÄÅ")
            e_context["reply"] = reply
            e_context.action = EventAction.BREAK_PASS
            return

        # ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ
        logger.info("[filesum] ÂºÄÂßãËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ")
        file_content = self.extract_content(file_path)
        if file_content is None:
            logger.info("[filesum] Êñá‰ª∂ÂÜÖÂÆπÊó†Ê≥ïÊèêÂèñ")
            reply = Reply(ReplyType.ERROR, "Êó†Ê≥ïËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ")
            e_context["reply"] = reply
            e_context.action = EventAction.BREAK_PASS
            return

        # Â∞ÜÊñá‰ª∂ÂÜÖÂÆπÂ≠òÂÖ•ÂÜÖÂÆπÁºìÂ≠ò
        try:
            self.content_cache[cache_key] = {
                'file_content': file_content,
                'processed': True
            }
            logger.info(f"[FileSum] Êñá‰ª∂ÂÜÖÂÆπÂ∑≤ÁºìÂ≠òÔºåcache_key={cache_key}")
            logger.info(f"[FileSum] ÁºìÂ≠òÂÜÖÂÆπÈïøÂ∫¶: {len(file_content)}")
            
            # È™åËØÅÁºìÂ≠òÊòØÂê¶ÊàêÂäü
            if cache_key in self.content_cache:
                logger.info("[FileSum] È™åËØÅÔºöÁºìÂ≠òÂÜôÂÖ•ÊàêÂäü")
            else:
                logger.error("[FileSum] È™åËØÅÔºöÁºìÂ≠òÂÜôÂÖ•Â§±Ë¥•")
            
        except Exception as e:
            logger.error(f"[FileSum] ÁºìÂ≠òÊñá‰ª∂ÂÜÖÂÆπÊó∂Âá∫Èîô: {str(e)}")
        
        # Â§ÑÁêÜÊñá‰ª∂ÂÜÖÂÆπ
        self.handle_file(file_content, e_context)
        
        # Â§ÑÁêÜÂÆåÊàêÂêéÂà†Èô§Êñá‰ª∂
        try:
            os.remove(file_path)
            logger.info(f"[filesum] Êñá‰ª∂ {file_path} Â∑≤Âà†Èô§")
            # Âà†Èô§Êñá‰ª∂Ë∑ØÂæÑÁºìÂ≠ò
            del self.file_cache[cache_key]
            # ËÆæÁΩÆ‰∫ã‰ª∂Áä∂ÊÄÅ‰∏∫ BREAK_PASS
            e_context.action = EventAction.BREAK_PASS
        except Exception as e:
            logger.error(f"[filesum] Âà†Èô§Êñá‰ª∂Â§±Ë¥•: {str(e)}")

    def extract_content(self, file_path):
        """ÊèêÂèñÊñá‰ª∂ÂÜÖÂÆπ"""
        try:
            # Ê∑ªÂä†Êñá‰ª∂Â§ßÂ∞èÊ£ÄÊü•
            file_size = os.path.getsize(file_path) / 1024  # ËΩ¨Êç¢‰∏∫KB
            if file_size > self.max_file_size:
                logger.error(f"Êñá‰ª∂Â§ßÂ∞è ({file_size}KB) Ë∂ÖËøáÈôêÂà∂ ({self.max_file_size}KB)")
                return None
            
            file_extension = os.path.splitext(file_path)[1].lower().replace('.', '')
            file_type = EXTENSION_TO_TYPE.get(file_extension)
            
            if file_type == 'pdf':
                return self.read_pdf(file_path)
            elif file_type == 'docx':
                return self.read_docx(file_path)
            elif file_type == 'md':
                return self.read_markdown(file_path)
            elif file_type == 'txt':
                return self.read_txt(file_path)
            elif file_type == 'excel':
                return self.read_excel(file_path)
            elif file_type == 'csv':
                return self.read_csv(file_path)
            elif file_type == 'html':
                return self.read_html(file_path)
            elif file_type == 'ppt':
                return self.read_ppt(file_path)
            else:
                logger.error(f"‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Á±ªÂûã: {file_extension}")
                return None
        except Exception as e:
            logger.error(f"ÊèêÂèñÊñá‰ª∂ÂÜÖÂÆπÊó∂Âá∫Èîô: {str(e)}")
            return None

    def read_pdf(self, file_path):
        """ËØªÂèñPDFÊñá‰ª∂"""
        try:
            doc = fitz.open(file_path)
            content = ' '.join([page.get_text() for page in doc])
            doc.close()
            return content
        except Exception as e:
            logger.error(f"ËØªÂèñPDFÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def read_docx(self, file_path):
        """ËØªÂèñWordÊñáÊ°£"""
        try:
            doc = Document(file_path)
            content = '\n'.join([paragraph.text for paragraph in doc.paragraphs])
            return content
        except Exception as e:
            logger.error(f"ËØªÂèñWordÊñáÊ°£Â§±Ë¥•: {str(e)}")
            return None

    def read_markdown(self, file_path):
        """ËØªÂèñMarkdownÊñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
            return remove_markdown(content)
        except Exception as e:
            logger.error(f"ËØªÂèñMarkdownÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def read_txt(self, file_path):
        """ËØªÂèñÊñáÊú¨Êñá‰ª∂"""
        encodings = ['utf-8', 'gbk', 'gb2312', 'ascii']
        for encoding in encodings:
            try:
                with open(file_path, 'r', encoding=encoding) as f:
                    return f.read()
            except UnicodeDecodeError:
                continue
            except Exception as e:
                logger.error(f"ËØªÂèñÊñáÊú¨Êñá‰ª∂Â§±Ë¥•: {str(e)}")
                return None
        return None

    def read_excel(self, file_path):
        """ËØªÂèñExcelÊñá‰ª∂"""
        try:
            wb = load_workbook(file_path)
            content = []
            for sheet in wb.worksheets:
                for row in sheet.iter_rows(values_only=True):
                    content.append('\t'.join([str(cell) if cell is not None else '' for cell in row]))
            return '\n'.join(content)
        except Exception as e:
            logger.error(f"ËØªÂèñExcelÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def read_csv(self, file_path):
        """ËØªÂèñCSVÊñá‰ª∂"""
        try:
            content = []
            with open(file_path, 'r', encoding='utf-8') as f:
                reader = csv.reader(f)
                for row in reader:
                    content.append('\t'.join(row))
            return '\n'.join(content)
        except Exception as e:
            logger.error(f"ËØªÂèñCSVÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def read_html(self, file_path):
        """ËØªÂèñHTMLÊñá‰ª∂"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                soup = BeautifulSoup(f.read(), 'html.parser')
                return soup.get_text()
        except Exception as e:
            logger.error(f"ËØªÂèñHTMLÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def read_ppt(self, file_path):
        """ËØªÂèñPPTÊñá‰ª∂"""
        try:
            prs = Presentation(file_path)
            content = []
            for slide in prs.slides:
                for shape in slide.shapes:
                    if hasattr(shape, "text"):
                        content.append(shape.text)
            return '\n'.join(content)
        except Exception as e:
            logger.error(f"ËØªÂèñPPTÊñá‰ª∂Â§±Ë¥•: {str(e)}")
            return None

    def handle_file(self, content, e_context):
        """Â§ÑÁêÜÊñá‰ª∂ÂÜÖÂÆπ"""
        try:
            if not content:
                reply = Reply(ReplyType.ERROR, "Êó†Ê≥ïËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ")
                e_context["reply"] = reply
                return

            # Áî®ÁΩÆ‰∏≠ÁöÑtokenÈôêÂà∂
            if len(content) > self.max_token_size:
                content = content[:self.max_token_size] + "..."
                logger.warning(f"Êñá‰ª∂ÂÜÖÂÆπÂ∑≤Êà™Êñ≠Âà∞ {self.max_token_size} ‰∏™Â≠óÁ¨¶")

            # ÁÆÄÂåñpromptËé∑ÂèñÈÄªËæë
            prompt = self.prompt  # Áõ¥Êé•‰ΩøÁî®ÈªòËÆ§promptÔºåÁßªÈô§params_cacheÁõ∏ÂÖ≥ÈÄªÔøΩÔøΩ

            # ÊûÑÂª∫ÊèêÁ§∫ËØç
            messages = [
                {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰∏™Êñá‰ª∂ÊÄªÁªìÂä©Êâã„ÄÇ"},
                {"role": "user", "content": f"{prompt}\n\n{content}"}
            ]

            # Ë∞ÉÁî®OpenAI API
            response = requests.post(
                f"{self.open_ai_api_base}/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.open_ai_api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": self.model,
                    "messages": messages
                }
            )

            if response.status_code == 200:
                result = response.json()
                summary = result['choices'][0]['message']['content']
                # Ê∑ªÂä†ËøΩÈóÆÊèêÁ§∫
                summary += f"\n\nüí° ÊÇ®ÂèØ‰ª•Âú®5ÂàÜÈíüÂÜÖÂèëÈÄÅ„Äå{self.qa_prefix}xxx„ÄçÊù•ËØ¢ÈóÆÊñá‰ª∂Áõ∏ÂÖ≥ÈóÆÈ¢ò"
                reply = Reply(ReplyType.TEXT, summary)
            else:
                reply = Reply(ReplyType.ERROR, "Ë∞ÉÁî®APIÂ§±Ë¥•")

            e_context["reply"] = reply

        except Exception as e:
            logger.error(f"Â§ÑÁêÜÊñá‰ª∂ÂÜÖÂÆπÊó∂Âá∫Èîô: {str(e)}")
            reply = Reply(ReplyType.ERROR, f"Â§ÑÁêÜÊñá‰ª∂Êó∂Âá∫Èîô: {str(e)}")
            e_context["reply"] = reply

    def handle_question(self, content, question, e_context):
        """Â§ÑÁêÜËøΩÈóÆ"""
        try:
            logger.info(f"[FileSum] ÂºÄÂßãÂ§ÑÁêÜËøΩÈóÆÔºåÈóÆÈ¢òÔºö{question}")
            
            # ÂÖàÂèëÈÄÅÁ≠âÂæÖÊ∂àÊÅØ
            reply = Reply(ReplyType.TEXT, "ü§î Ê≠£Âú®ÊÄùËÄÉÊÇ®ÁöÑÈóÆÈ¢òÔºåËØ∑Á®çÂÄô...")
            channel = e_context["channel"]
            channel.send(reply, e_context["context"])
            
            # ÊûÑÂª∫ÊèêÁ§∫ËØç
            messages = [
                {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰∏™Êñá‰ª∂ÈóÆÁ≠îÂä©Êâã„ÄÇËØ∑Âü∫‰∫éÁªôÂÆöÁöÑÊñá‰ª∂ÂÜÖÂÆπÂõûÁ≠îÈóÆÈ¢ò„ÄÇ"},
                {"role": "user", "content": f"Êñá‰ª∂ÂÜÖÂÆπÂ¶Ç‰∏ãÔºö\n\n{content}\n\nÈóÆÈ¢òÔºö{question}"}
            ]

            logger.info("[FileSum] ÂºÄÂßãË∞ÉÁî® OpenAI API")
            response = requests.post(
                f"{self.open_ai_api_base}/chat/completions",
                headers={
                    "Authorization": f"Bearer {self.open_ai_api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": self.model,
                    "messages": messages,
                    "temperature": 0.7,
                    "max_tokens": 1000
                },
                timeout=30
            )

            logger.info(f"[FileSum] API ÂìçÂ∫îÁä∂ÊÄÅÁ†Å: {response.status_code}")
            
            if response.status_code == 200:
                result = response.json()
                answer = result['choices'][0]['message']['content']
                logger.info(f"[FileSum] Ëé∑ÂæóÂõûÁ≠îÔºåÈïøÂ∫¶Ôºö{len(answer)}")
                logger.info(f"[FileSum] ÂõûÁ≠îÂÜÖÂÆπÔºö{answer}")
                
                # ËÆæÁΩÆÂõûÂ§ç
                reply = Reply(ReplyType.TEXT, answer)
                e_context["reply"] = reply
                e_context.action = EventAction.BREAK_PASS
                return
                
            else:
                logger.error(f"[FileSum] APIË∞ÉÁî®Â§±Ë¥•: {response.text}")
                reply = Reply(ReplyType.ERROR, "Ë∞ÉÁî®APIÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï")
                e_context["reply"] = reply
                e_context.action = EventAction.BREAK_PASS
                return

        except requests.exceptions.RequestException as e:
            logger.error(f"[FileSum] APIËØ∑Ê±ÇÂºÇÂ∏∏: {str(e)}")
            reply = Reply(ReplyType.ERROR, "ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï")
            e_context["reply"] = reply
            e_context.action = EventAction.BREAK_PASS
            return
        except Exception as e:
            logger.error(f"[FileSum] Â§ÑÁêÜËøΩÈóÆÊó∂Âá∫Èîô: {str(e)}")
            reply = Reply(ReplyType.ERROR, "Â§ÑÁêÜÈóÆÈ¢òÊó∂Âá∫ÈîôÔºåËØ∑ÈáçËØï")
            e_context["reply"] = reply
            e_context.action = EventAction.BREAK_PASS
            return

def remove_markdown(text):
    """ÁßªÈô§MarkdownÊ†ºÂºè"""
    # ÁßªÈô§Ê†áÈ¢ò
    text = re.sub(r'#{1,6}\s+', '', text)
    # ÁßªÈô§Âä†Á≤óÂíåÊñú‰Ωì
    text = re.sub(r'\*{1,2}(.*?)\*{1,2}', r'\1', text)
    # ÁßªÈô§ÈìæÊé•
    text = re.sub(r'\[([^\]]+)\]\([^\)]+\)', r'\1', text)
    # ÁßªÈô§‰ª£Á†ÅÂùó
    text = re.sub(r'```[\s\S]*?```', '', text)
    # ÁßªÈô§Ë°åÂÜÖ‰ª£Á†Å
    text = re.sub(r'`([^`]+)`', r'\1', text)
    return text.strip()